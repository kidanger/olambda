#!/usr/bin/env octave-cli

if exist('iio_read') ~= 3 || exist('iio_write') ~= 3
    fprintf(2, 'olambda fatal error: could not find ''iio_read'' and/or ''iio_write''.\n');
    fprintf(2, 'Please check your installation of iio''s octave bindings.\n');
    fprintf(2, '(you should download https://github.com/mnhrdt/iio/tree/master/contrib/octave and add the mex files to your octave path using ''$HOME/.octaverc''.)\n');
    exit(1);
end

arg_list = argv();
n = nargin;

% parse '-p' to print the output in the terminal instead of writing to file
print = false;
for i=1:n
    if strcmp(arg_list{i}, '-p')
        print = true;
        arg_list(i, :) = [];
        n = n - 1;
        break;
    end
end

% parse '-h' to print the usage
showhelp = false;
for i=1:n
    if strcmp(arg_list{i}, '-h')
        showhelp = true;
        arg_list(i, :) = [];
        n = n - 1;
        break;
    end
end

% parse '-v' for verbose mode
verbose = false;
for i=1:n
    if strcmp(arg_list{i}, '-v')
        verbose = true;
        arg_list(i, :) = [];
        n = n - 1;
        break;
    end
end

% parse '-o' for the output filename
output = '-';
for i=1:n
    if strcmp(arg_list{i}, '-o') ~= 0
        output = arg_list{i+1};
        arg_list(i:i+1, :) = [];
        n = n - 2;
        break;
    end
end

% display usage if needed or asked
if n == 0 || showhelp
    fprintf(2, 'usage: olambda [-h] [-v] [-p] [-o <output>] [<images>...] <statements;expression>\n');
    return;
end

% parse the octave code
prog = arg_list{n};
arg_list(n, :) = [];
n = n - 1;

% read the images
imgs = {};
imgs_names = ['x':'z', 'a':'w']; % we do not handle more than 26 input images
for i=1:n
    imgs{i} = iio_read(arg_list{i});
    if verbose
        fprintf(2, ['%c=''%s'' (%d' ...
                    repmat('x%d', [1, length(size(imgs{i}))-1]) ')\n'], ...
            imgs_names(i), arg_list{i}, size(imgs{i}));
    end
end

preprog = '';
for i=1:n
    preprog = [preprog imgs_names(i) '=imgs{' int2str(i) '};'];
end
prog = [preprog prog ';']; % two semicolons are ok

% run the code on the image
% the result is saved as the variable r
eval(prog);

% ans is not defined if either all results are assigned to a variable, or the
% statment is not a calculation (e.g. 'x').
% In this case, assign to r the last used variable.
% For example 'x(1:2:end,1:2:end)'
if ~exist('ans','var')
    lastvar = prog;
    lastvar(regexp(lastvar, ' ')) = []; % remove all whitespaces
    while true
        pos = regexp(lastvar, ';;');
        if ~isempty(pos), lastvar(pos+1) = []; else, break; end
    end
    lastvar(regexp(lastvar, ';$')) = []; % remove last ';'
    lastvar = [';' lastvar]; % add leading ';' for following command
    pos = regexp(lastvar, ';'); pos = pos(end); % last ';'
    lastvar = lastvar(pos+1);
    if verbose
        fprintf(2,'lastvar: %c\n', lastvar);
    end
    eval(['r=' lastvar ';']);
else
    r = ans;
end

if verbose
    fprintf(2, 'running ''%s''\n', prog);
    fprintf(2, ['result: %d' repmat('x%d', [1, length(size(r))-1]) ' %s\n'],
        size(r), class(r));
end

% print or save the result
if print || ischar(r) || numel(r) == 1
    disp(r);
else
    iio_write(output, r);
end

% vim: ft=octave
